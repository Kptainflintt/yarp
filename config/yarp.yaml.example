# Configuration YARP - Exemple Simple
system:
  hostname: test-router
  domain: lab.local       # Appliqué dans /etc/resolv.conf (domain + search) et /etc/hosts (FQDN)
  timezone: Europe/Paris  # Appliqué via /etc/localtime et /etc/timezone (nécessite tzdata)
  dns_servers:            # Serveurs DNS écrits dans /etc/resolv.conf (nameserver)
    - 1.1.1.1
    - 8.8.8.8

# Configuration des logs
logging:
  # Niveau de logs: DEBUG, INFO, WARNING, ERROR
  level: INFO

  # Mode debug activé par défaut pour voir plus de détails
  debug: false

  # Logs dans les fichiers
  files:
    # Log principal de l'application
    application: "/var/log/yarp/apply.log"
    # Log détaillé pour debug (si debug: true)
    debug: "/var/log/yarp/debug.log"
    # Log des erreurs uniquement
    error: "/var/log/yarp/error.log"

  # Formats de logs
  formats:
    # Format console (ce que voit l'utilisateur)
    console: "simple"  # simple, detailed, minimal
    # Format fichier (logs structurés)
    file: "json"       # json, text, detailed

  # Modules spécialisés
  modules:
    network: INFO      # Logs networking
    routing: INFO      # Logs routing
    dns: INFO          # Logs DNS (resolv.conf)
    firewall: WARNING  # Logs firewall (moins verbeux par défaut)

interfaces:
  # Interface WAN (vers Internet)
  eth0:
    description: "Interface WAN"
    ipv4: dhcp
    # Configuration NAT masquerading
    masquerading: true
    masquerade_sources:
      - "192.168.1.0/24"     # Réseau LAN principal
      - "10.0.0.0/24"        # Réseau supplémentaire

  # Interface LAN (réseau local)
  eth1:
    description: "Interface LAN"
    ipv4: 192.168.1.1/24
    ipv6: fd00:1::1/64

routing:
  static:
    # Route par défaut vers le WAN
    - to: 0.0.0.0/0
      via: 192.168.100.1
      interface: eth0

    # Route vers un sous-réseau spécifique
    - to: 10.0.0.0/24
      via: 192.168.1.254
      metric: 10

firewall:
  # Politiques par défaut (accept, drop, reject)
  default:
    input: drop
    forward: drop
    output: accept

  # Suivi de connexion (conntrack) - accepte automatiquement
  # les connexions établies et le trafic loopback
  stateful: true

  # Règles de filtrage (évaluées dans l'ordre)
  #
  # chain (obligatoire) : input, forward, output
  #   input   = trafic destiné au routeur lui-même
  #   forward = trafic traversant le routeur
  #   output  = trafic émis par le routeur
  #
  # Critères de matching (au moins un requis) :
  #   source         : IP, CIDR source ou "any" (ex: 192.168.1.0/24, 10.0.0.1, any)
  #   destination    : IP, CIDR destination ou "any"
  #   in_interface   : interface d'entrée (ex: eth0) — pas compatible avec chain: output
  #   out_interface  : interface de sortie (ex: eth1) — pas compatible avec chain: input
  #
  # protocols : dict {tcp: ..., udp: ..., icmp: true, gre: true} ou "any"
  #   L4 (avec ports) : tcp, udp, sctp
  #   L3 (sans ports) : icmp, gre, esp, ah, ipip, ospf, vrrp
  # Ports acceptés : int (80), liste ([80, 443]), range ("8000:8100")
  # action : accept, drop, reject
  rules:
    # Autoriser le SSH vers le routeur (INPUT, pas FORWARD)
    - name: "Allow SSH"
      chain: input
      source: any
      in_interface: eth1
      protocols:
        tcp: 22
      action: accept

    # Autoriser le trafic HTTP/HTTPS et DNS du LAN vers le WAN
    - name: "Allow Internet"
      chain: forward
      source: 192.168.1.0/24
      out_interface: eth0
      protocols:
        tcp: [80, 443]
        udp: 53
      action: accept

    # Autoriser le trafic HTTP depuis le WAN vers un serveur LAN
    - name: "Allow HTTP from WAN"
      chain: forward
      in_interface: eth0
      destination: 192.168.1.100
      protocols:
        tcp: 80
      action: accept

    # Autoriser le ping (ICMP) du LAN vers le WAN
    - name: "Allow Ping out"
      chain: forward
      in_interface: eth1
      out_interface: eth0
      protocols:
        icmp: true
      action: accept

    # Autoriser un range de ports pour une application
    - name: "Allow app ports"
      chain: forward
      source: 192.168.1.0/24
      out_interface: eth0
      protocols:
        tcp: "8000:8100"
      action: accept

    # Autoriser les tunnels GRE (protocole L3, pas de ports)
    - name: "Allow GRE tunnels"
      chain: input
      in_interface: eth0
      destination: 192.168.1.1
      protocols:
        gre: true
      action: accept

    # Bloquer tout le reste du WAN vers le LAN
    - name: "Block WAN to LAN"
      chain: forward
      in_interface: eth0
      out_interface: eth1
      protocols: any
      action: drop
